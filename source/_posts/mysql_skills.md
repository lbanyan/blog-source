---
title: MySQL InnoDB使用技巧
tags:
    - MySQL使用技巧
---

### COUNT(1)和COUNT(*)
不用关心这两种哪种快，除非到了需要优化他们的地步。
不一定哪个更快，跟表结构、数据规模、在不同索引下的数据分布...都有关系，需要优化时，用线上的数据实际测试下，再优化。

### 数据库的性能
不要迷信数据库的性能，有时候运维说几百万行性能也没问题，这是严重错误的，例如表中有字段存入的是大量的字符串，这种几万行即使简单的查询都会极慢的。

<!--more-->

### INSERT INTO...VALUES...ON DUPLICATE KEY UPDATE...
不存在则插入，存在则修改。
使用场景，例如统计用户登录次数，该用户在登录统计表中不存在，则将其登录次数设置为1，存在，则登录次数加1。
在并发情况下，这种方式可以将锁级别从业务上的锁降到数据库级的锁，一方面使得业务层代码更加简单，另一方面锁粒度的降低，有可能带来效率的提升。如果不使用这种方式，业务层势必要先查询相应记录，如果存在则修改，如果不存在则插入，这就有可能出现并发问题。

### 查询单条记录，执行业务后，修改此记录
通常的做法，业务层先从数据库中查询符合条件的记录，然后修改这条记录。
在并发场景下，这种做法不适用。思考这种情况，A和B线程同时对表中处于WAITING状态的记录查询后进行业务处理，处理完成将状态标记为OK。如果使用上述方法，A和B可能拿到相同的记录，导致执行重复的业务动作，即使有数据库层面的乐观锁保户，但是业务的重复执行有时也会带来严重的问题。
采用业务层的锁机制，只允许A执行或只允许B执行，是可以解决，不过还有一种更简单的方式，就是将锁级别降低到数据库级。
由于简单的UPDATE后，并不会返回修改的结果记录，而是返回受影响的条目数。在不知道修改了哪条记录的情况下，当然不能基于这条记录执行相关业务了。如何能在UPDATE的同时，知道是哪个条目被修改了呢。
还是以上面的例子为例，可以考虑在表中增加一个标记修改字段locked，整个流程先执行修改操作：
```
UPDATE...SET status = 'OK' AND locked = uuid;
```
然后根据此uuid获取到修改了的那行记录，并执行相关业务即可。这样的话，可以保证A和B线程不会获取到相同的记录，也避免了业务不会重复执行，由于这种锁有可能是数据库级的行级锁，在性能上也要优于业务上加锁。
当然，此处也可以不增加locked字段，而直接去修改此表的主键来代替：
```
UPDATE...SET status = 'OK' AND id = uuid;
```
但是频繁的修改索引对数据库性能是有影响的，不建议。

### 查询多条记录，执行相关业务后，修改符合业务条件的记录
简单的SELECT，有可能会产生和上面那个例子同样的问题。而且如果并没有一个类似于上述例子中只是修改status字段，即该记录修改后还是可以立马再次被修改的。
如何在数据库层面解决这个问题呢，可以使用以下语句：
``` sql
SELECT...FROM...WHERE...FOR UPDATE
```
其中WHERE应尽可能包含此表的索引，这样InnoDB在可以确定某些行记录的情况下，会使用行级锁，效率会更高。在A和B线程同时执行该业务时，如果A和B锁定的是不同的数据，也可以并行执行，而不会出现锁冲突。

### 行转列
举个例子，有如下表：

| eventId                              | taskId                               | code             | status  |
|:-------------------------------------|:-------------------------------------|:-----------------|:--------|
| 00056443-bb9d-45a8-81f5-d91cd72ceacd | 68c40f88-fc1c-4b62-9d09-4620d739ef48 | config_etc_hosts | SUCCESS |
| 0005cac0-8656-4238-8b17-38d4e896e777 | 68c40f88-fc1c-4b62-9d09-4620d739ef48 | deploy_java | WAITING |
| 0064c9e6-475b-41ab-b5b9-797b246bec80 | 00dc017f-53a9-4681-a460-dd142679eb31 | deploy_java | WAITING |
| 0121ed96-a198-4101-a139-2a11b792b6fd | 00dc017f-53a9-4681-a460-dd142679eb31 | config_etc_hosts | WAITING |

此表中主键为eventId，一个task任务由多个event组成，此表记录了一个任务执行的各事件过程。如何将其转换成下述形式：

| taskId                               | config_etc_hosts | deploy_java |
|:-------------------------------------|:-----------------|:------------|
| 68c40f88-fc1c-4b62-9d09-4620d739ef48 | SUCCESS          | WAITING     |
| 00dc017f-53a9-4681-a460-dd142679eb31 | WAITING          | WAITING     |

来表示一个任务每步执行的状态呢？这种转换主要用于前端展示。
可以使用下述语句：
``` sql
SELECT
	t.taskId taskId,
	max(

		IF (
			t.`code` = 'config_etc_hosts',
			t.`status`,
			NULL
		)
	) config_etc_hosts,
	max(

		IF (
			t.`code` = 'deploy_java',
			t.`status`,
			NULL
		)
	) deploy_java
FROM
	ConfigModuleTaskLog t
GROUP BY
	t.taskId
```
其中IF语句的意思是：IF（判断条件，TRUE，FALSE）

