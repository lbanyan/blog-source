---
title: 检测半开连接
date: 2018-02-05 18:36
tags:
    - 半开连接
    - TCP
    - Keepalive
    - Half-Open Connections
---

> 本文翻译自： [Detection of Half-Open (Dropped) Connections](https://blog.stephencleary.com/2009/05/detection-of-half-open-dropped.html)

TCP 协议使用三次握手建立连接，四次挥手关闭连接。但是，连接一旦建立，如果双方都没有发送任何数据，那么该连接上也不会有数据包通过。TCP 协议是“惰性”的，除非证明连接无效，否则它很乐意认为该连接是有效的。

<!--more-->

TCP 以提高灵活性和效率来设计。这种设计可以使连接从网线拔断或路由器崩溃中恢复正常。例如，客户端已和服务器建立了连接，中间路由器有可能会重启，在路由器重启之后，原连接仍然可用（这种情况是正常的，除非在路由器关闭期间客户端或服务器端通过该连接发送数据）。这种设计也是高效的，因为没有使用只是为了检测连接是否仍然正常的“轮询”数据包，从而减少了不必要的网络流量。

TCP 实际是有数据确认机制，所以当一方向另一方发送数据时，在连接正常时，会收到一个 ACK 消息。因此，断开的连接可以通过发送数据来检测。需要注意的是，接收数据的行为在 TCP 中是完全被动的；只读 Socket 无法检测到已断开的连接。

这将导致“半开连接”的情况出现。在大多数协议的任何给定点，一方预计会发送一条消息，而另一方期望接收到它。考虑一下当一个中间路由器突然重启时会发生什么情况：接收方将继续等待消息到达；发送方将发送其数据，并收到一个连接丢失的错误指示。由于断开的连接只能通过发送数据来检测，接收方将永远等待。这种情况被称为“半开连接”，因为一方意识到连接丢失，另一方认为它仍然可用。

> 注意：“半开”与“半闭”完全不同。半闭连接是当一方对其套接字执行关闭操作时，仅关闭发送（传出）流。有关关闭操作的更多详细信息，请参阅 [套接字操作](https://blog.stephencleary.com/2009/05/socket-operations.html) 一文。

#### 半开连接的原因

半开连接就是那些在测试环境中很少见到，但在现实世界中普遍发生的烦人的问题。这是因为如果套接字以正常的四次握手关闭（或者即使突然关闭），也不会发生半开问题。下面介绍一些半开连接的常见原因：

- 进程崩溃。如果一个进程正常关闭，通常会发送一个“FIN”包，通知对方连接已经关闭。但是，如果进程崩溃或终止（例如，从任务管理器终止），对对端的“FIN”通知是不能保证发送的。操作系统有可能代表崩溃的进程发送一个“FIN”数据包；不过，这取决于操作系统。
- 电脑死机。如果整个计算机（包括操作系统）崩溃或断电，肯定无法通知对方连接已经断开。
- 路由器崩溃/重启。客户端和服务器连接之间的任何路由器也可能崩溃或重启；如果此时一方正在发送数据，则会导致连接中断，发送方的连接断开。如果在此期间双方没有数据发送，那么连接不会断开。
- 拔掉网络电缆。客户端和服务器连接之间的网络电缆断开都会导致连接中断而不通知。这与路由器的情况类似；如果在电缆断开到接通期间，没有数据正在传输，则连接实际上不会丢失。但是，计算机通常会检测是否拔掉了特定的网络电缆，并且可能会通知其本地套接字网络丢失（远程端不会被通知）。
- 无线设备（包括笔记本电脑）超出范围。移出接入点范围的无线设备将失去连接。这是一个经常被忽视但日益普遍的情况。

在上述所有情况下，一方有可能知道连接丢失，另一方可能不知道。

#### 明确的检测是必要的吗？

在某些情况下，检测是不必要的。一个“轮询”系统（而不是“订阅/事件”系统）已经有一个内置的定时器（轮询定时器），并定期通过连接发送数据。所以轮询方不需要明确检查连接丢失。

通信双方都必须分别考虑检测的必要性。例如，如果协议基于轮询方案，那么执行轮询的一方不需要显式的 Keepalive，但是响应的另一方是需要显式的 Keepalive 处理的。

> 真实的故事：我曾经不得不编写软件来控制通过“桥接”设备运行的串行设备，该桥接设备通过 TCP/IP 暴露一个串行端口。开发该网桥的公司实现了一个简单的协议：他们监听 TCP/IP 连接，一旦连接建立，将从该连接接收到的任何数据转发到这个串行端口。当然，它们只允许一个 TCP/IP 连接（否则可能会导致串口冲突），所以只要建立了一个连接，其他连接将被拒绝。
问题出在没有 keepalive。如果桥接处于半开状态，它将永远不会恢复；任何连接请求都会被拒绝，因为网桥会认为原来的连接仍然有效。通常情况下，网桥作为固定设备部署在物理网络上；而且如果设备停止工作，有人可能会走过去进行电源重启。但是，我们将该网桥作为移动设备部署在无线网络中，而且我们的设备在接入点覆盖范围内进进出出是正常的。此外，这是一个自动化系统的一部分，人们并不能接近该设备来执行电源重启。当然，该网桥方案在我们的起初设计中是失败的。我们将根本的原因告知该网桥设备公司，以引起他们的注意，但他们无法实现一个Keepalive（嵌入式 TCP/IP 堆栈不支持它），所以他们与我们合作开发一种远程重置网桥的方案。
需要注意的是，我们确实在连接的一方（通过计时器）进行了 Keepalive 测试，但这是不够的。连接的两端都需要进行 Keepalive 测试。
该网桥在市场中流通已经有一段时间了。该网桥设备公司是一家十亿美元级跨国网络设备公司。我工作的公司当时有四个程序员。这只是表明，即使是大公司也会犯错误。

#### 检测连接断开的错误方法

有几种错误的方法来检测连接断开。一般 Socket 相关开发人员经常想出这些半开问题的不正确解决方法。这里列出的错误方法仅供参考，并简要说明它们为什么是错的。

- 第二个 Socket 连接。在任何情况下，新建的 Socket 连接都无法确定已有连接的有效性。特别是，如果远程端已经崩溃并重新启动，则即使原始连接处于半开状态，新 Socket 连接尝试也将成功。
- Ping。向远程端发送 Ping（ICMP）也有同样的问题：即使连接不可用，Ping 也可能成功。而且，ICMP 是工作在网际层的，其行为和工作在传输层的 TCP 也有所不同。

#### 检测连接丢弃的正确方法

对于半开问题有几个正确的解决方案。每个方案各有优缺点，取决于使用场景。解决方案由好到差依次如下：

- 为应用 [程序协议框架](https://blog.stephencleary.com/2009/04/message-framing.html) 添加 Keepalive 消息（一个空的消息）。允许长度前缀或带分隔符的消息系统可以发送空消息（例如，长度前缀为0字节或单个结束分隔符的消息)。
  - 优点。上层协议（实际用户消息）不受影响。
  - 缺点。这需要连接两端更新该底层应用程序，所以如果该底层并不是你可以改变的时候，该方案是不可行的。
- 上层应用协议添加一个 Keepalive 消息（一个“null”消息）。这为应用程序协议添加了一条新消息策略：一个“null”消息应该被忽略。
  - 优点。如果应用协议使用非统一的底层消息帧系统，则可以使用这种方法。这是在第一种解决方案不能使用时才使用的方案。
  - 缺点。（与第一种解决方案相同）这需要对连接两端的软件进行更改，因此，如果该应用程序协议已经指定且不可变，则该选项可能不可用。
- 超时断开。使用定时器，并假定在定时器到期时连接已经被丢弃（当然，每当数据传输时定时器将被重置）。这是支持持久连接的 HTTP 服务器工作的方式。
  - 优点。不需要更改应用程序协议。此外，该解决方案可以减少网络流量，它是唯一不需要使用 Keepalive 包（即“你还在吗？”）的解决方案。
  - 缺点。该方案可能会导致大量的有效连接被丢弃。
- 使用 TCP/IP Keepalive 包设置。这是一个非常有争议的解决方案，有正面和负面的复杂论点。在 [Stevens的书](https://blog.stephencleary.com/2009/05/tcpip-resources.html) 第23章中对此进行了深入的讨论。本质上，它指定 TCP/IP 堆栈以应用程序的名义周期性地发送 Keepalive 数据包。
  - 优点。如果支持该 Keepalive 参数设置，应用程序是不需要改变的。其他解决方案都是需要应用程序必须响应相关计时器事件的；这一个是“设定然后忘记”的方案。
  - 缺点。RFC 1122第4.2.3.6节指出，对于没有数据的 TCP Keepalive 包可能无法由路由器可靠地传送；这可能会导致有效连接被丢弃。此外，TCP/IP 堆栈根本不需要支持 Keepalive （而且许多嵌入式堆栈不支持），所以这个解决方案不具备多平台兼容性。

有两种方法可以让 TCP/IP 堆栈代表应用程序发送 Keepalive 包：

- 设置 SocketOptionName.KeepAlive。MSDN 文档并没有明确说明此处使用2小时超时，2小时超时对于大多数应用程序来说太长了。这可以通过修改注册表来设置，但是该参数是全局性的（即所有其他应用程序共用），修改该值是非常不合适的。这是使 keepalive 数据包生效的传统方法。
- 设置每个连接的 Keepalive。Keepalive 参数只能在 Windows 2000 和更新的版本上设置。这必须通过向 Socket 发布 I/O 控制代码来完成：将 [IOControlCode.KeepAliveValues](https://msdn.microsoft.com/en-us/library/system.net.sockets.iocontrolcode.aspx) 和一些数据一起传递给 [Socket.IOControl](https://msdn.microsoft.com/en-us/library/system.net.sockets.socket.iocontrol.aspx) ；.NET文档不包含这些数据的结构，但在 [WSAIoctl（SIO_KEEPALIVE_VALS）](https://msdn.microsoft.com/en-us/library/ms741621.aspx) 的非托管文档中进行了说明。

应用协议的每一方都可以采用不同的 KeepAlive 解决方案，甚至在协议的不同状态下使用不同的 KeepAlive 解决方案。例如，请求/响应式协议的客户端可以选择在没有挂起请求时发送“null”请求，并在等待响应时切换到超时解决方案。

但是，在设计新的协议时，最好只采用一种解决方案。