---
title: MySQL相关基础知识
tags:
    - MySQL
---

> MySQL引擎有哪些，各引擎的不同之处，事务级别，ACID，死锁，索引，BTREE。

<!--more-->

## MySQL引擎
MySQL引擎主要有**MyISAM与InnoDB**两种，当然还有其他的。目前我们业务使用的引擎都是InnoDB，此两类引擎的对比可以参看这两篇博客： [MySQL存储引擎InnoDB与Myisam的六大区别](https://my.oschina.net/junn/blog/183341)和 [MyISAM InnoDB 区别](http://www.cnblogs.com/youxin/p/3359132.html) 。总结一下就是**InnoDB支撑事务、外键和行级锁**，删改较多的业务首选InnoDB；**MyISAM插入查询速度快、支撑全文检索、体积小、维护方便**，很适合监控平台记录监控使用。

## MySQL事务
可以参考[Innodb中的事务隔离级别和锁的关系](https://tech.meituan.com/innodb-lock.html)、[mysql隔离级别及事务传播](https://gist.github.com/JagoWang/4555317)和[MySQL事务隔离级别详解](http://xm-king.iteye.com/blog/770721)。

### 事务级别
- 未提交读(Read Uncommitted)：允许脏读，也就是可能读取到其他会话中未提交事务修改的数据。
- 提交读(Read Committed)：只能读取到已经提交的数据。Oracle等多数数据库默认都是该级别 (不重复读)。
- 可重复读(Repeated Read)：可重复读。在同一个事务内的查询都是事务开始时刻一致的，InnoDB默认级别。在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻读。
- 串行读(Serializable)：完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞。

### 锁
MySQL InnoDB中，在可明确指定某行的情况下，使用行锁，否则使用表锁。例如：
``` sql
select ... from ... where ... for update;
```
在where中包含索引时，且同时可以明确要修改的是某行时，数据库使用行锁；如果不包含索引或不能明确要修改某行时，数据库使用的是表锁。

一次封锁：一次将所有涉及数据全部加锁，处理完成，再全部解锁，效率慢，一般不用。
两段锁：
- 加锁阶段：读申请共享锁（S锁），写申请排它锁（X锁），用到时申请，一个一个申请，申请失败，事务进入等待状态，知道申请成功为止；
- 解锁阶段：解锁阶段，只能解锁，不能再加锁。

悲观锁：读取数据时加锁，其他事务无法修改此数据；写数据时加锁，其他事务无法读取此数据。
乐观锁：根据数据的版本来锁。A和B同时修改同一条记录，拿到了相同的版本号，A先修改完成，此记录的版本号变化，B提交修改时，由于B所持版本号和数据库当前此记录版本号不一致，则拒绝B提交。

InnoDB 可重复读，尽力避免幻读使用Next-Key锁，其是行锁和间隙锁（GAP）的合并。A事务已读取全表，正准备修改全表，同时B事务插入一条新记录，此时，InnoDB会让B事务处于等待状态，直到A事务提交完成。

## 数据库事务的4个特性：ACID

- 原子性（Atomic）：组成一个事务的多个数据库操作是一个不可分割的原子单元；只有所有操作执行成功，整个事务才提交，其中一个操作失败，都必须回滚到初始状态。
- 一致性（Consistency）：事务操作成功后数据库所处的状态和它的业务规则是一致的；（即数据总额不会被破坏。如A账户转账100到B账户，无论操作成功与否，A和B的存款总额是不变的）。
- 隔离性（Isolation）：在并发数据操作时，不同的事务拥有各自的数据空间，它们的操作不会对彼此产生干扰。（并非是完全无干扰，根据数据库的隔离级别，会产生不同程度的干扰）。
- 持久性（Durability）：一旦事务提交成功，事务中的数据操作都必须持久化到数据库中；就算数据库崩溃，也必须保证有某种机制恢复。

## 索引
可以参考[MySQL索引背后的数据结构及算法原理](https://www.kancloud.cn/kancloud/theory-of-mysql-index)和[MySQL 和 B 树的那些事](http://blog.jobbole.com/105644/)
B-树的关键字和记录是放在一起的，叶子节点可以看作外部节点，不包含任何信息；B+树的非叶子节点中只有关键字和指向下一个节点的索引，记录只放在叶子节点中。
红黑树就是平衡二叉树。

## 启动项目时自动生成或更新数据库表结构
在使用Hibernate时，设置hibernate.hbm2ddl.auto属性为update，可以在启动项目时自动生成或更新数据库表结构，这样部署项目或更新表结构就变得非常方便。但应注意的是，表中删除属性以及修改属性的类型、长度等并不会自动更新，还需要手动到数据库去执行命令更新。
